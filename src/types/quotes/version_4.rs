use super::{CertData, QuoteHeader, body::*};
use crate::constants::{ENCLAVE_REPORT_LEN, SGX_TEE_TYPE, TD10_REPORT_LEN, TDX_TEE_TYPE};
use serde::{Serialize, Deserialize};
use serde_big_array::BigArray;

#[derive(Clone, Debug, Serialize, Deserialize)]
pub struct QuoteV4 {
    pub header: QuoteHeader,            // [48 bytes]
                                        // Header of Quote data structure.
                                        // This field is transparent (the user knows its internal structure).
                                        // Rest of the Quote data structure can be treated as opaque (hidden from the user).
    pub quote_body: QuoteBody,          // May either contain a SGX Enclave Report (384 bytes) or TD10 Report (584 bytes)
    pub signature_len: u32,             // [4 bytes]
                                        // Size of the Quote Signature Data structure in bytes.
    pub signature: QuoteSignatureDataV4,             // [variable bytes]
}

impl QuoteV4 {
    pub fn from_bytes(raw_bytes: &[u8]) -> Self {
        let header = QuoteHeader::from_bytes(&raw_bytes[0..48]);
        let quote_body;
        let mut offset: usize = 48;
        match header.tee_type {
            SGX_TEE_TYPE => {
                offset += ENCLAVE_REPORT_LEN;
                quote_body = QuoteBody::SGXQuoteBody(EnclaveReport::from_bytes(&raw_bytes[48..offset]));
            },
            TDX_TEE_TYPE => {
                offset += TD10_REPORT_LEN;
                quote_body = QuoteBody::TD10QuoteBody(TD10ReportBody::from_bytes(&raw_bytes[48..offset]));
            },
            _ => {
                panic!("Unknown TEE type")
            }
        }
        let signature_len = u32::from_le_bytes([
            raw_bytes[offset], 
            raw_bytes[offset + 1], 
            raw_bytes[offset + 2], 
            raw_bytes[offset + 3]
        ]);
        offset += 4;
        let signature_slice = &raw_bytes[offset..offset+signature_len as usize];
        let signature = QuoteSignatureDataV4::from_bytes(signature_slice);

        QuoteV4 {
            header,
            quote_body,
            signature_len,
            signature,
        }
    }

    pub fn to_bytes(&self) -> Vec<u8> {
        let mut raw_bytes = Vec::new();
        let mut header_bytes = self.header.to_bytes().to_vec();
        let mut quote_body_bytes = match self.quote_body {
            QuoteBody::SGXQuoteBody(enclave_report) => enclave_report.to_bytes().to_vec(),
            QuoteBody::TD10QuoteBody(report) => report.to_bytes().to_vec()
        };
        let mut signature_len_bytes = u32::to_le_bytes(self.signature_len).to_vec();
        let mut signature_bytes = self.signature.to_bytes();
        raw_bytes.append(&mut header_bytes);
        raw_bytes.append(&mut quote_body_bytes);
        raw_bytes.append(&mut signature_len_bytes);
        raw_bytes.append(&mut signature_bytes);
        raw_bytes
    }
}

#[derive(Clone, Debug, Serialize, Deserialize)]
pub struct QuoteSignatureDataV4 {
    #[serde(with = "BigArray")]
    pub quote_signature: [u8; 64],      // [64 bytes]
                                        // ECDSA signature, the r component followed by the s component, 2 x 32 bytes.
                                        // Public part of the Attestation Key generated by the Quoting Enclave.
    #[serde(with = "BigArray")]
    pub ecdsa_attestation_key: [u8; 64],// [64 bytes]
                                        // EC KT-I Public Key, the x-coordinate followed by the y-coordinate (on the RFC 6090 P-256 curve), 2 x 32 bytes.
                                        // Public part of the Attestation Key generated by the Quoting Enclave.
    pub qe_cert_data: CertData,         // [variable bytes]
                                        // QE Cert Data
}

impl QuoteSignatureDataV4 {
    pub fn from_bytes(raw_bytes: &[u8]) -> Self {
        let mut quote_signature = [0; 64];
        quote_signature.copy_from_slice(&raw_bytes[0..64]);
        let mut ecdsa_attestation_key = [0; 64];
        ecdsa_attestation_key.copy_from_slice(&raw_bytes[64..128]);
        let qe_cert_data = CertData::from_bytes(&raw_bytes[128..]);

        QuoteSignatureDataV4 {
            quote_signature,
            ecdsa_attestation_key,
            qe_cert_data,
        }
    }

    pub fn to_bytes(&self) -> Vec<u8> {
        let mut raw_bytes = Vec::new();
        let mut quote_signature_bytes = self.quote_signature.clone().to_vec();
        let mut ecdsa_attestation_key_bytes = self.ecdsa_attestation_key.clone().to_vec();
        let mut qe_cert_data_bytes = self.qe_cert_data.to_bytes();
        raw_bytes.append(&mut quote_signature_bytes);
        raw_bytes.append(&mut ecdsa_attestation_key_bytes);
        raw_bytes.append(&mut qe_cert_data_bytes);
        raw_bytes
    }
}
